import argparse
import codecs
import os.path as path
from lxml import etree
from io import StringIO, BytesIO
import json
from always_replace import smart_replace

argumentparser = argparse.ArgumentParser(description="""
        """)
argumentparser.add_argument(
        "html_to_modify",
        help="html file to modify",
        type=str)
argumentparser.add_argument(
        "mapping_file",
        help="mapping generated by the preprocessing script (in json)",
        type=str)
argumentparser.add_argument(
        "-o",
        "--output_file",
        help="output file. if not given, 'modified' is added to the input file to create outputfile",
        type=str)

options = argumentparser.parse_args()
htmlparser = etree.HTMLParser()
root_path, extension = path.splitext(options.html_to_modify)
if options.output_file:
    output_filepath = options.output_file
else:
    output_filepath = "{}.modified{}".format(root_path, extension)

trans_dict = json.load(codecs.open(options.mapping_file, 'r', 'utf-8'))
#print(trans_dict)

page = etree.parse(StringIO(codecs.open(options.html_to_modify, 'r', 'utf-8').read()), htmlparser)

for entry_num, (key, value) in enumerate(trans_dict.items()):
    page.xpath(key)[0].text = smart_replace(key, value)

print("Modified {} entries".format(entry_num))

modified_page = etree.tostring(page, pretty_print=True).decode('utf-8')
ourput_file = codecs.open(output_filepath, 'w', 'utf-8')
ourput_file.write(modified_page)
print("Saved modified page to '{}'".format(output_filepath))
